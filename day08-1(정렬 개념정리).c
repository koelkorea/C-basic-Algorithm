// 정렬
//  : 데이터 그룹 요소를 특정 기준으로 오름차순이나 내림차순으로 정리
//    -> 데이터를 집합으로 그룹화할 때 가장 기본적이고 중요한 알고리즘

//  1. 버블 정렬(bubble sort)
//     : 1싸이클당 데이터 그룹 요소의 비교대상 선정은 왼쪽부터 정렬 할 값을 선택한 후, 그 대상의 인접한 데이터...
//       -> 비교 결과 그 두 인접한 요소가 순서대로 되어 있지 않으면 자리를 교환
//       -> 그렇게 전체가 정렬 될 때까지 비교 & 교환의 반복
//       -> 다음 싸이클의 비교대상은 2번째 자리에서 2~3, 3~4 이런식으로 반복

//     # 시간 복잡도 : n * (n + 1) / 2 = n^2  

//  2. 삽입 정렬(insertion sort)
//     : 1싸이클당 데이터 그룹 요소의 비교대상 선정은 왼쪽부터 정렬 할 값을 선택하고, 그 녀석이 위치할 자리를 찾아 타요소들과 1:1로 전부 비교 
//       -> 값 비교 결과 배열의 오름차순(or 내림차순)을 기준으로 맞지 않는 결과가 나올시 N번째 요소와 교환
//          (= 대상값이 정렬된 배열에서 위치할 자리를 찾아 삽입하는 것과 같은 정렬방식)
//       -> 다음 싸이클의 비교대상은 2번째 자리 <-> 3 ~ n번째까지 비교

//     # 시간 복잡도 : n * (n + 1) / 2 = n^2  

//  3. 쉘 정렬(Shell sort)
//     : 1싸이클당 데이터 그룹 요소의 전체 리스트를 일정 숫자로 나눈 숫자의 결과값을 간격으로 정함
//       -> 1번째 값을 기준으로 간격별로 떨어진 값을 모아서, 부분 리스트로 나눔
//       -> 그렇게 만들어진 부분 리스트를 정렬해줌
//       -> 2번째 ~ 간격 -1 까지의 값들도 마찬가지로 부분리스트 정렬을 마침
//       -> 2번째 싸이클부터는 간격/(나누는수 * n)으로 간격을 점점 좁힌다
//          (= 그렇게 하면 간격이 1인 녀석을 수행 가능하게 됨)

//     # 시간 복잡도 : n^1.5  
//     # 논문에서는 나누는 값은 2가 가장 이상적이라고 함 (= 해보니까 어차피 최대공약수가 1인 녀석을 나누는 수로 쓰는 경우 부분리스트가 축소되지 않음)
//     # 쉘 정렬의 의의?
//       : 시간복잡도 = 비교횟수 + 교환횟수...  
//         -> 교환횟수를 줄이면? 시간복잡도가 줄어든다 
//            (= 애초에 비교를 효율적으로 해서 오름차순, 내림차순에 맞는 수가 최대한 빨리 자기 자리에 가까운 곳에 위치하면? 교환횟수가 줄지 않겠냐?
//         -> 각 시작점의 간격별로 부분 리스트를 만들고 비교를 해서, 각 그룹에서 가장 높거나 작은수를 앞으로 보내는걸 반복하면 좋겠지?
//            (= 분할정복법 사용 = 작은 해를 종합해서 큰 문제를 해결하기)

//     # 분할정복법
//       : 문제를 최소단위로 분리(단순화) -> 최소단위 1개를 해결하며 나머지를 반복  -> 해결된 최소단위의 결과를 모아서 원래의 문제를 해결하는 전략
//         -> if 분리된 문제가 아직도 해결하기 어렵다면, 다시 분할 적용 (재귀호출을 활용한 녀석)


//        ex)  입력 배열
//             10	8	6	20	4	3	22	1	0	15	16
//             
//             간격 5를 기준 - 비교대상 정리
//             10					3					16
//                 8					22
//                     6					1
//                         20					0
//                             4					15
//             
//             간격 5를 기준 - 부분적 리스트 정렬 후
//             3					10					16
//                 8					22
//                     1					6
//                         0					20
//                             4					15
//             
//             간격 5 배열 정렬 후
//             3	8	1	0	4	10	22	6	20	15	16
//             
//             간격 3를 기준 - 비교대상 정리
//             3			0			22			15
//                 8			4			6			16
//                     1			10			20
//             
//             간격 3를 기준 - 부분적 리스트 정렬 후
//             0			3			15			22
//                 4			6			8			16
//                     1			10			20
//             
//             간격 3 배열 정렬 후
//             0	4	1	3	6	10	15	8	20	22	16
//             
//             간격 1 배열 정렬 후
//             0	1	3	4	6	8	10	15	16	20	22

//  4. 합병 정렬 (Merge sort)
//     : 합병정렬은 집합을 2개로 나누고 나누고 계속 나눠서, 더 이상 분할하면 정렬이 불가능해지는 수준까지 나눈 뒤, 각각을 정렬하고 이를 다시 하나로 합쳐서 정렬하는 방식으로 순서바꾸는 횟수를 최소화

//     # 시간 복잡도 : n * log(n) n
//     # 합병 정렬의 의의?
//       : 시간복잡도 = 비교횟수 + 교환횟수...  
//         -> 교환횟수를 줄이면? 시간복잡도가 줄어든다 
//         -> 2개씩 묶어서 정렬한 묶음들을 또 2의 배수씩 붙여서, 다시 정렬하다보면 더 효율적이지 않것냐?
//            (= 분할정복법 사용 = 작은 해를 종합해서 큰 문제를 해결하기)

//     # 분할정복법(bottom-top)
//       : 문제를 최소단위로 분리(단순화) -> 최소단위 1개를 해결하며 나머지를 반복  -> 해결된 최소단위의 결과를 모아서 원래의 문제를 해결하는 전략
//         -> if 분리된 문제가 아직도 해결하기 어렵다면, 다시 분할 적용 (재귀호출을 활용한 녀석)

//     # 쉘정렬 vs 합병정렬
//       - 공통점 : 분할정복법 사용
//       - 차이점 : 부분리스트를 만드는 방법의 차이.. (쉘정렬 : x의 배수별로 n/x에 수렴하는 리스트의 수 -> 2개로 수렴, 합병정렬 : n/2에 해당하는 수의 부분리스트 -> 2개로 수렴)

//  5. 퀵 정렬(Quick sort)
//     : 기준값을 정해두고, 왼쪽에서부터 i + 1번째 데이터와 n - i + 1번째 데이터를 비교하고, 정렬방법에 따라 이들을 교환함
//       -> 포인터가 중앙점인 교차점을 넘어가게 되면, 그 부분을 중심으로 리스트를 반토막내서 다시 같은 방식으로 비교 반복
//       -> 더 이상 분할이 불가능한 최소 단위(1개)로 분할 될 때까지 이를 반복

//     # 시간 복잡도 : n * log(n) n
//     # 평균적으로 가장 빠른 정렬 방법
//     # top-bottom(= 큰 문제를 해결하는 과정에서 분할해서 작은 문제를 해결하기) 방식 사용

//  6. 버킷(기수) 정렬(Radix sort)
//     : 리스트의 데이터의 값을 보고, 그 값에 해당하는 메모리나 배열의 위치에 이놈들을 저장하는 방식
//       -> 그럼 1000000000자리의 수까지가 존재하면, 그만한 수의 메모리크기가 필요하것네?
//          -> 그럴 필요 없이, 1의 자리부터 ~ 10^k개의 자리수에 해당하는 녀석들을 0~9까지 10개 씩 만들어 주고, 이를 필터를 통해 거르는 방식으로 확장해 나가면 그만
//             -> 그렇게 하면, 시간복잡도를 10^k자리수의 k*n정도의 조회수에 수렴하게 줄일수가 있음
//                (= 대신 메모리를 그만큼 또 사용해야 함 = 공간복잡도는 반작용으로 상승)

//     # 시간 복잡도 : k * n
//     # 버킷 정렬 특징
//       - 레코드를 비교하지 않고도 정렬하는 방법
//       - O(nlogn) 이라는 이론적인 하한선을 깰 수 있는 유일한 방법
//       - O(kn) 의 시간 복잡도를 가지는데 대부분 k < 4 이하
//       - 자료형이 동일한 길이를 가지는 숫자나 문자열로 구성
