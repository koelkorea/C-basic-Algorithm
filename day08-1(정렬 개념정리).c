// 정렬
//  : 데이터 그룹 요소를 특정 기준으로 오름차순이나 내림차순으로 정리
//    -> 데이터를 집합으로 그룹화할 때 가장 기본적이고 중요한 알고리즘

//  1. 버블 정렬(bubble sort)
//     : 1싸이클당 데이터 그룹 요소의 비교대상 선정은 왼쪽부터 정렬 할 값을 선택한 후, 그 대상의 인접한 데이터...
//       -> 비교 결과 그 두 인접한 요소가 순서대로 되어 있지 않으면 자리를 교환
//       -> 그렇게 전체가 정렬 될 때까지 비교 & 교환의 반복
//       -> 다음 싸이클의 비교대상은 2번째 자리에서 2~3, 3~4 이런식으로 반복

//     # 시간 복잡도 : n * (n + 1) / 2 = n^2  

//  2. 삽입 정렬(insertion sort)
//     : 1싸이클당 데이터 그룹 요소의 비교대상 선정은 왼쪽부터 정렬 할 값을 선택하고, 그 녀석이 위치할 자리를 찾아 타요소들과 1:1로 전부 비교 
//       -> 값 비교 결과 배열의 오름차순(or 내림차순)을 기준으로 맞지 않는 결과가 나올시 N번째 요소와 교환
//          (= 대상값이 정렬된 배열에서 위치할 자리를 찾아 삽입하는 것과 같은 정렬방식)
//       -> 다음 싸이클의 비교대상은 2번째 자리 <-> 3 ~ n번째까지 비교

//     # 시간 복잡도 : n * (n + 1) / 2 = n^2  

//  3. 쉘 정렬(Shell sort)
//     : 1싸이클당 데이터 그룹 요소의 전체 리스트를 일정 숫자로 나눈 숫자의 결과값을 간격으로 정함
//       -> 1번째 값을 기준으로 간격별로 떨어진 값을 모아서, 부분 리스트로 나눔
//       -> 그렇게 만들어진 부분 리스트를 정렬해줌
//       -> 2번째 ~ 간격 -1 까지의 값들도 마찬가지로 부분리스트 정렬을 마침
//       -> 2번째 싸이클부터는 간격/(나누는수 * n)으로 간격을 점점 좁힌다
//          (= 그렇게 하면 간격이 1인 녀석을 수행 가능하게 됨)

//     # 시간 복잡도 : n^1.5  
//     # 논문에서는 나누는 값은 2가 가장 이상적이라고 함 (= 해보니까 어차피 최대공약수가 1인 녀석을 나누는 수로 쓰는 경우 부분리스트가 축소되지 않음)
//     # 쉘 정렬의 의의?
//       : 시간복잡도 = 비교횟수 + 교환횟수...  
//         -> 교환횟수를 줄이면? 시간복잡도가 줄어든다 
//            (= 애초에 비교를 효율적으로 해서 오름차순, 내림차순에 맞는 수가 최대한 빨리 자기 자리에 가까운 곳에 위치하면? 교환횟수가 줄지 않겠냐?
//         -> 각 시작점의 간격별로 부분 리스트를 만들고 비교를 해서, 각 그룹에서 가장 높거나 작은수를 앞으로 보내는걸 반복하면 좋겠지?
//            (= 작은 해를 종합해서 큰 문제를 해결하기)

//        ex)  입력 배열
//             10	8	6	20	4	3	22	1	0	15	16
//             
//             간격 5를 기준 - 비교대상 정리
//             10					3					16
//                 8					22
//                     6					1
//                         20					0
//                             4					15
//             
//             간격 5를 기준 - 부분적 리스트 정렬 후
//             3					10					16
//                 8					22
//                     1					6
//                         0					20
//                             4					15
//             
//             간격 5 배열 정렬 후
//             3	8	1	0	4	10	22	6	20	15	16
//             
//             간격 3를 기준 - 비교대상 정리
//             3			0			22			15
//                 8			4			6			16
//                     1			10			20
//             
//             간격 3를 기준 - 부분적 리스트 정렬 후
//             0			3			15			22
//                 4			6			8			16
//                     1			10			20
//             
//             간격 3 배열 정렬 후
//             0	4	1	3	6	10	15	8	20	22	16
//             
//             간격 1 배열 정렬 후
//             0	1	3	4	6	8	10	15	16	20	22

