// 그래프(graph)
//  : 연결되어 있는 정점(vertex) 간의 관계를 간선(edge)로 표현하는 자료구조 (트리도 그래프의 일종)
//    ex) 지도      : 각 위치는 정점, 경로는 간선
//        운송망    : 각 터미널은 정점, 항로, 가격은 간선 -> 가장 빠르거나 가장 저렴한 경로를 계산
//        SNS       : 각 사용자는 정점, 친구 관계는 간선
//        구글 검색  : 각 주제는 정점, 상대적 중요도(인용, 참조)는 간선

//  # 그래프의 구성 요소
//    - 정점(vertex) : 노드의 집합
//    - 간선(edge)   : 정점 쌍의 집합 (정점을 연결하는 선)
//       -> 무방향
//           : 어느쪽이더라도 접근가능 (= 조합의 개념)
//              ex) {0, 1}
//       -> 단방향
//           : 특정 방향을 시작점으로만 접근가능(= 순열의 개념)
//              ex) <0, 1>  <- 꺾쇠 사용

//  # 그래프 용어
//    - 인접 정점(adjacent vertex)
//       : 간선에 의해 연결된 정점을 말한다.
//    - 차수(degree)
//       : 정점에 연결된 다른 정점의 개수, 정점 0의 차수는 3 (1, 2, 3)
//    - 경로(path)
//       : 정점의 나열로 표현 
//         ex) 단순경로 : 0, 1, 2, 3
//             사이클(cycle) : 0, 1, 2, 0
//    - 경로 길이
//       : 경로를 구성하는데 사용된 간선의 수
//    - 완전그래프
//       : 모든 정점이 연결되어 있는 그래프

//  # 그래프 종류
//    1. 무방향 그래프 (Undirected)
//        : 방향이 없는 간선을 가진 그래프(양방향)
//          ex) (0, 1) == (1, 0)

//    2. 방향 그래프(Directed)
//        : 방향이 있는 간선을 가진 그래프(단방향)
//          ex) <0, 1> != <1, 0>

//    3. 가중치 그래프(Weighted)
//        : 간선에 정점의 연관된 값을 갖는 그래프

//    4. 순환 그래프(cycle)
//        : 1개 이상의 사이클(cycle)을 가져 순환이 가능한 그래프


// 그래프를 표현하는 방법
//  1. 인접 행렬
//     : 2차원 배열로 그래프 표현 
//       -> (방법) x축을 시작노드, y축을 도착점으로 단방향 형식 간선을 그래프에 표기
//       -> (문제점) 정점이 10개 이상만 넘어가도 ㅈㄴ게 복잡함
// 
//  2. 인접 리스트
//     : 각 정점에 인접한 정점들을 연결리스트로 표현
//       -> (방법) 각 정점에서 자신에게 연결된 정점들에 대해서만 linkedlist 방식을 통해 연결주소를 붙혀둠


// 깊이 우선 탐색 (DFS : Depth First Search)
//  : 그래프를 하나의 정점(보통 root)으로부터 시작하여, 차례대로 모든 정점들을 한번씩 방문
//     -> 보통 stack 자료구조를 활용해서 구현

//  # DFS를 사용하여 미로 탐색 문제해결 예시
//     : 미로를 탐색할 때처럼 한 방향으로 갈 수 있을 때까지 계속 진행하는 경우
//        -> 이를 더 이상 갈 수 없게 되면, 다시 가장 가까운 갈림길로 복귀후 다른 방향으로 다시 탐색을 반복하는 식으로 문제를 해결하는 것과 유사함

//    - 해결법 1) 
//       : 'stack 자료구조'와 boolean형식의 배열을 사용하여 해결
//          (1) 하나의 정점을 stack에 push해둠
//          (2) stack이 빌때까지 그 정점을 pop 하고, 그 정점에 대한 방문노드체크 배열의 해당 노드항목을 방문으로 변경 (pop = print 로 간주함)
//          (3) pop 된 정점에서 방문하지 않은 인접한 정점들을 다시 stack에 push
//          (4) stack이 빌 때까지 2번 3번을 반복하고, 더 이상 방문하지 않은 정점이 나올때까지 이를 계속 반복 (whlie문 쓰면 쉽다)

//    - 해결법 2)
//       : '재귀함수'와 boolean형식의 배열을 사용하여 해결 (= 재귀함수를 쓰는거 또한 stack을 쓰는 셈)
//          -> 함수는 메모리의 stack영역에서 함수프레임을 형성하며, 그 안에서 다른 함수를 호출하면 stack구조로 쌓이고 빠지고하며 LIFO방식 작동
//             (1) 하나의 정점을 출발지로 정함
//             (2) 방문 메서드 수행 후, 그 정점에 대한 방문노드체크 배열의 해당 노드항목을 방문으로 변경 (pop = print 로 간주함)
//             (3) 현재 정점에서 방문하지 않은 인접한 정점들중 하나를 잡고 이동
//             (4) 2번 3번을 반복하고 인접정점이 NULL이면 이전 갈림길로 돌아가서 계속, 더 이상 방문하지 않은 정점이 나올때까지 이를 계속 반복


// 너비 우선 탐색(Breadth First Search)
//  : 그래프를 시작점에서 더 가까운 곳을 순회 (노드를 레벨별로 순회한다는게 정확)
//    -> 보통 큐를 사용해 구현
// 
//  # BFS를 사용하여 미로 탐색 문제해결 예시
//     : 미로를 탐색할 때, 일단 어디에 갈림길이 있는지 체크하고, 하나하나 경우의 수를 다 확인해가며 진행하는 경우
//        -> 경우를 확인하면, 일단 더 진행하지 않고 갈림길로 복귀후 다른 방향으로 다시 탐색을 반복하는 식으로 문제를 해결하는 것과 유사함
//           (1) 하나의 정점을 queue에 enqueue 추가해 둠
//           (2) queue의 정점을 dequeue(= print) 제거 후, 그 정점에 대한 방문노드체크 배열의 해당 노드항목을 방문으로 변경(pop = print 로 간주함)
//           (3) queue가 빌 때까지 이를 2번을 반복
//           (4) 현재 정점에서 방문하지 않은 방문하지 않은 인접한 정점들을 전부 queue에 순차적으로 추가
//           (5) 큐가 빌 때까지 2번 3번 4번을 반복, 더 이상 방문하지 않은 정점이 나올때까지 이를 계속 반복(whlie문 쓰면 쉽다)


